import os
import io
import asyncio
import pandas as pd
import xml.etree.ElementTree as ET
from dataclasses import dataclass
from typing import List, Dict, Optional
from aiogram import Bot, Dispatcher, F
from aiogram.types import Message, FSInputFile, CallbackQuery
from aiogram.filters import Command
from aiogram.utils.keyboard import InlineKeyboardBuilder

# =============================
# –ù–∞—Å—Ç—Ä–æ–π–∫–∏
# =============================
TOKEN = os.getenv("TELEGRAM_TOKEN", "8437309662:AAEpCVFP75iE23G725ydP-L_PtZRjhWC9ws")
CURRENCY = "UAH"
LOG_FILE = "bot_log.txt"
PREVIEW_ROWS = 5

SRC = {
    "id": ["product code", "main sku", "–∫–æ–¥", "–∞—Ä—Ç–∏–∫—É–ª"],
    "name": ["name", "–Ω–∞–∑–≤–∞", "–Ω–∞–∑–≤–∞–Ω–∏–µ"],
    "qty": ["quantity", "–∫—ñ–ª—å–∫—ñ—Å—Ç—å", "–∫–æ–ª–∏—á–µ—Å—Ç–≤–æ"],
    "price": ["special price", "price", "—Ü—ñ–Ω–∞", "—Ü–µ–Ω–∞"],
    "description": ["description", "–æ–ø–∏—Å", "–æ–ø–∏—Å–∞–Ω–∏–µ"],
    "photos": ["main photo", "photo1", "photo2", "photo3", "photo4",
               "photo5", "photo6", "photo7", "photo8", "photo9", "photo10",
               "–ø–æ—Å–∏–ª–∞–Ω–Ω—è_–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è", "–∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ"],
    "params_primary": [
        ("size of the set", "–†–æ–∑–º—ñ—Ä –∫–æ–º–ø–ª–µ–∫—Ç—É"), ("size extra", "–î–æ–¥–∞—Ç–∫–æ–≤–∏–π —Ä–æ–∑–º—ñ—Ä"),
        ("sheet size", "–†–æ–∑–º—ñ—Ä –ø—Ä–æ—Å—Ç–∏—Ä–∞–¥–ª–∞"), ("size of the pillowcase", "–†–æ–∑–º—ñ—Ä –Ω–∞–≤–æ–ª–æ—á–∫–∏"),
        ("dimensions of the duvet cover", "–†–æ–∑–º—ñ—Ä –ø—ñ–¥–∫–æ–≤–¥—Ä–∏"), ("fabric type", "–¢–∏–ø —Ç–∫–∞–Ω–∏–Ω–∏"),
        ("composition", "–°–∫–ª–∞–¥"), ("density", "–©—ñ–ª—å–Ω—ñ—Å—Ç—å"), ("color", "–ö–æ–ª—ñ—Ä"),
        ("country of manufacture", "–ö—Ä–∞—ó–Ω–∞ –≤–∏—Ä–æ–±–Ω–∏–∫"), ("brand registration country", "–ö—Ä–∞—ó–Ω–∞ —Ä–µ—î—Å—Ç—Ä–∞—Ü—ñ—ó –±—Ä–µ–Ω–¥—É"),
        ("producer", "–í–∏—Ä–æ–±–Ω–∏–∫"), ("sheet", "–ü—Ä–æ—Å—Ç–∏—Ä–∞–¥–ª–æ"), ("pillowcase", "–ù–∞–≤–æ–ª–æ—á–∫–∞"),
        ("a feature of pillowcases", "–û—Å–æ–±–ª–∏–≤—ñ—Å—Ç—å –Ω–∞–≤–æ–ª–æ—á–æ–∫"), ("sheet with elastic band", "–ü—Ä–æ—Å—Ç–∏—Ä–∞–¥–ª–æ –Ω–∞ —Ä–µ–∑–∏–Ω—Ü—ñ"),
        ("gift packaging", "–ü–æ–¥–∞—Ä—É–Ω–∫–æ–≤–∞ —É–ø–∞–∫–æ–≤–∫–∞"), ("available layout options", "–î–æ—Å—Ç—É–ø–Ω—ñ –∫–æ–º–ø–ª–µ–∫—Ç–∞—Ü—ñ—ó"),
        ("fabrics \"a\" (top of the quilt)", "–¢–∫–∞–Ω–∏–Ω–∞ A (–≤–µ—Ä—Ö –∫–æ–≤–¥—Ä–∏)"),
        ("fabrics \"b\" (bed sheet)", "–¢–∫–∞–Ω–∏–Ω–∞ B (–ø—Ä–æ—Å—Ç–∏—Ä–∞–¥–ª–æ)"), ("bonus", "–ë–æ–Ω—É—Å")
    ]
}

PROM_XLS_COLS = [
    "–ö–æ–¥_—Ç–æ–≤–∞—Ä—É", "–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó", "–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó_—É–∫—Ä", "–û–ø–∏—Å", "–û–ø–∏—Å_—É–∫—Ä",
    "–¶—ñ–Ω–∞", "–í–∞–ª—é—Ç–∞", "–ö—ñ–ª—å–∫—ñ—Å—Ç—å", "–ü–æ—Å–∏–ª–∞–Ω–Ω—è_–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è"
] + [
    f"{prefix}_{i}" for i in range(1, 21) for prefix in (
        "–ù–∞–∑–≤–∞_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏", "–û–¥–∏–Ω–∏—Ü—è_–≤–∏–º—ñ—Ä—É_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏", "–ó–Ω–∞—á–µ–Ω–Ω—è_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏"
    )
]
# =============================
# –£—Ç–∏–ª–∏—Ç—ã
# =============================
def normalize_df(df: pd.DataFrame) -> pd.DataFrame:
    df = df.copy()
    df.columns = [str(c).strip().lower() for c in df.columns]
    return df

def find_first_col(df: pd.DataFrame, candidates: List[str]) -> Optional[str]:
    for c in candidates:
        if c in df.columns:
            return c
    return None

def build_image_list(row: pd.Series) -> List[str]:
    urls: List[str] = []
    for col in SRC["photos"]:
        if col in row and pd.notna(row[col]):
            urls.extend([p.strip() for p in str(row[col]).split(",") if p.strip()])
    return list(dict.fromkeys(urls))[:10]

def pick_price(row: pd.Series) -> Optional[float]:
    for c in SRC["price"]:
        if c in row and pd.notna(row[c]):
            try:
                return float(str(row[c]).replace(",", ".").strip())
            except Exception:
                return None
    return None

def merge_ru_ua(df_ru: pd.DataFrame, df_ua: pd.DataFrame) -> pd.DataFrame:
    df_ru = normalize_df(df_ru)
    df_ua = normalize_df(df_ua)
    col_id_ru = find_first_col(df_ru, SRC["id"]) or "–∫–æ–¥"
    col_id_ua = find_first_col(df_ua, SRC["id"]) or "–∫–æ–¥"
    col_name_ru = find_first_col(df_ru, SRC["name"]) or "–Ω–∞–∑–≤–∞–Ω–∏–µ"
    col_name_ua = find_first_col(df_ua, SRC["name"]) or "–Ω–∞–∑–≤–∞"
    df_ru["_id"] = df_ru[col_id_ru].astype(str).str.strip()
    df_ua["_id"] = df_ua[col_id_ua].astype(str).str.strip()
    ua = df_ua[['_id', col_name_ua]].rename(columns={col_name_ua: '–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó_—É–∫—Ä'})
    merged = df_ru.merge(ua, on='_id', how='left')
    merged['–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó'] = merged[col_name_ru].astype(str)
    merged['–ö–æ–¥_—Ç–æ–≤–∞—Ä—É'] = merged['_id']
    return merged

def to_prom_excel(df: pd.DataFrame) -> pd.DataFrame:
    rows: List[Dict] = []
    col_qty = find_first_col(df, SRC['qty']) or 'quantity'
    for _, r in df.iterrows():
        item: Dict[str, Optional[str]] = {c: '' for c in PROM_XLS_COLS}
        item['–ö–æ–¥_—Ç–æ–≤–∞—Ä—É'] = r.get('–ö–æ–¥_—Ç–æ–≤–∞—Ä—É', '')
        item['–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó'] = r.get('–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó', '')
        item['–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó_—É–∫—Ä'] = r.get('–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó_—É–∫—Ä', '')
        item['–¶—ñ–Ω–∞'] = pick_price(r) or ''
        item['–í–∞–ª—é—Ç–∞'] = CURRENCY
        item['–ö—ñ–ª—å–∫—ñ—Å—Ç—å'] = r.get(col_qty, '')
        item['–ü–æ—Å–∏–ª–∞–Ω–Ω—è_–∑–æ–±—Ä–∞–∂–µ–Ω–Ω—è'] = ', '.join(build_image_list(r))
        triplets: List[tuple] = []
        for eng, uk in SRC['params_primary']:
            if eng in r and pd.notna(r[eng]):
                val = str(r[eng]).strip()
                if val:
                    triplets.append((uk, '', val))
        for i, (nm, unit, val) in enumerate(triplets, start=1):
            item[f'–ù–∞–∑–≤–∞_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏_{i}'] = nm
            item[f'–û–¥–∏–Ω–∏—Ü—è_–≤–∏–º—ñ—Ä—É_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏_{i}'] = unit
            item[f'–ó–Ω–∞—á–µ–Ω–Ω—è_–•–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∏_{i}'] = val
        rows.append(item)
    return pd.DataFrame(rows)

def to_prom_yml(df: pd.DataFrame) -> str:
    def xml_safe(val: str) -> str:
        return str(val).replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')
    col_qty = find_first_col(df, SRC['qty']) or 'quantity'
    yml = ET.Element('yml_catalog')
    shop = ET.SubElement(yml, 'shop')
    offers = ET.SubElement(shop, 'offers')
    for _, r in df.iterrows():
        base_id = str(r.get('–ö–æ–¥_—Ç–æ–≤–∞—Ä—É', '')).strip()
        if not base_id: continue
        offer = ET.SubElement(offers, 'offer', id=base_id, available='true')
        name = r.get('–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó', '')
        name_ua = r.get('–ù–∞–∑–≤–∞_–ø–æ–∑–∏—Ü—ñ—ó_—É–∫—Ä', '')
        price = pick_price(r)
        qty = r.get(col_qty, None)
        images = build_image_list(r)
        if name: ET.SubElement(offer, 'name').text = xml_safe(name)
        if name_ua: ET.SubElement(offer, 'name_ua').text = xml_safe(name_ua)
        if price is not None: ET.SubElement(offer, 'price').text = str(price)
        ET.SubElement(offer, 'currencyId').text = CURRENCY
        if pd.notna(qty): ET.SubElement(offer, 'quantity_in_stock').text = str(qty)
        for url in images: ET.SubElement(offer, 'picture').text = xml_safe(url)
        for eng, uk in SRC['params_primary']:
            if eng in r and pd.notna(r[eng]):
                val = str(r[eng]).strip()
                if val: ET.SubElement(offer, 'param', name=uk).text = xml_safe(val)
    xml_bytes = ET.tostring(yml, encoding='utf-8')
    return '<?xml version="1.0" encoding="UTF-8"?>\n' + xml_bytes.decode('utf-8')

def log_error(msg: str):
    with open(LOG_FILE, 'a', encoding='utf-8') as f:
        f.write(msg + '\n')
    print('[LOG]', msg)

@dataclass
class Session:
    desired_format: Optional[str] = None
    files: List[pd.DataFrame] = None
# =============================
# –ë–æ—Ç
# =============================
class PromBot:
    def __init__(self, token: str):
        self.bot = Bot(token)
        self.dp = Dispatcher()
        self.sessions: Dict[int, Session] = {}
        self._register_handlers()

    def _fmt_kb(self) -> InlineKeyboardBuilder:
        kb = InlineKeyboardBuilder()
        kb.button(text='üìÑ XLSX', callback_data='fmt:xlsx')
        kb.button(text='üßæ YML', callback_data='fmt:yml')
        kb.adjust(2)
        return kb

    def _ensure_session(self, uid: int) -> Session:
        if uid not in self.sessions:
            self.sessions[uid] = Session(desired_format=None, files=[])
        return self.sessions[uid]

    def _register_handlers(self):
        dp = self.dp

        # === –û—Å–Ω–æ–≤–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã ===
        @dp.message(Command('start'))
        async def start(message: Message):
            sess = self._ensure_session(message.from_user.id)
            sess.files.clear()
            await message.answer(
                'üöÄ –ü—Ä–∏–≤–µ—Ç! –û—Ç–ø—Ä–∞–≤—å –¥–≤–∞ Excel-—Ñ–∞–π–ª–∞ (RU –∏ UA).\n–í—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞:',
                reply_markup=self._fmt_kb().as_markup()
            )

        @dp.message(Command('info'))
        async def info(message: Message):
            await message.answer(
                '‚ÑπÔ∏è –ë–æ—Ç –ø–æ–∑–≤–æ–ª—è–µ—Ç –æ–±—ä–µ–¥–∏–Ω—è—Ç—å —Ñ–∞–π–ª—ã RU/UA, –≥–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å XLSX/YML —Å —Ö–∞—Ä–∞–∫—Ç–µ—Ä–∏—Å—Ç–∏–∫–∞–º–∏, —Ñ–æ—Ç–æ –∏ —Ü–µ–Ω–æ–π.\n'
                '–ö–æ–º–∞–Ω–¥—ã: /start, /info, /clear, /preview, /validate, /onlyphoto, /onlyprice, /infoaboutparsing, /showlog, /stop'
            )

        @dp.message(Command('clear'))
        async def clear_files(message: Message):
            sess = self._ensure_session(message.from_user.id)
            sess.files.clear()
            await message.answer('üóëÔ∏è –°—Ç–∞—Ä—ã–µ —Ñ–∞–π–ª—ã –æ—á–∏—â–µ–Ω—ã.')

        @dp.message(Command('preview'))
        async def preview(message: Message):
            sess = self._ensure_session(message.from_user.id)
            if not sess.files:
                await message.answer('‚ö†Ô∏è –§–∞–π–ª—ã –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.')
                return
            previews = []
            for i, df in enumerate(sess.files, start=1):
                previews.append(f'–§–∞–π–ª {i}:\n{df.head(PREVIEW_ROWS).to_string()}')
            await message.answer('\n\n'.join(previews))

        @dp.message(Command('validate'))
        async def validate(message: Message):
            sess = self._ensure_session(message.from_user.id)
            missing = []
            required_cols = ['id', 'name', 'price']
            for df in sess.files:
                for col in required_cols:
                    if not find_first_col(df, SRC[col]):
                        missing.append(col)
            if missing:
                await message.answer(f'‚ö†Ô∏è –û—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç –∫–æ–ª–æ–Ω–∫–∏: {set(missing)}')
            else:
                await message.answer('‚úÖ –í—Å–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º—ã–µ –∫–æ–ª–æ–Ω–∫–∏ –ø—Ä–∏—Å—É—Ç—Å—Ç–≤—É—é—Ç.')

        @dp.message(Command('onlyphoto'))
        async def onlyphoto(message: Message):
            sess = self._ensure_session(message.from_user.id)
            if not sess.files:
                await message.answer('‚ö†Ô∏è –§–∞–π–ª—ã –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.')
                return
            df = pd.concat(sess.files)
            out_df = df[['–ö–æ–¥_—Ç–æ–≤–∞—Ä—É'] + SRC['photos'][:10]]
            out_path = f'photos_{message.from_user.id}.xlsx'
            out_df.to_excel(out_path, index=False)
            await message.answer_document(FSInputFile(out_path), caption='üì∏ –¢–æ–ª—å–∫–æ —Ñ–æ—Ç–æ')
            os.remove(out_path)

        @dp.message(Command('onlyprice'))
        async def onlyprice(message: Message):
            sess = self._ensure_session(message.from_user.id)
            if not sess.files:
                await message.answer('‚ö†Ô∏è –§–∞–π–ª—ã –µ—â—ë –Ω–µ –∑–∞–≥—Ä—É–∂–µ–Ω—ã.')
                return
            df = pd.concat(sess.files)
            out_df = df[['–ö–æ–¥_—Ç–æ–≤–∞—Ä—É']]
            out_df['–¶–µ–Ω–∞'] = df.apply(pick_price, axis=1)
            out_path = f'price_{message.from_user.id}.xlsx'
            out_df.to_excel(out_path, index=False)
            await message.answer_document(FSInputFile(out_path), caption='üí∞ –¢–æ–ª—å–∫–æ —Ü–µ–Ω—ã')
            os.remove(out_path)

        @dp.message(Command('infoaboutparsing'))
        async def infoaboutparsing(message: Message):
            sess = self._ensure_session(message.from_user.id)
            total_rows = sum(len(df) for df in sess.files) if sess.files else 0
            await message.answer(f'üìä –í—Å–µ–≥–æ –ø–æ–∑–∏—Ü–∏–π –≤ —Ç–µ–∫—É—â–∏—Ö —Ñ–∞–π–ª–∞—Ö: {total_rows}')

        @dp.message(Command('showlog'))
        async def showlog(message: Message):
            if not os.path.exists(LOG_FILE):
                await message.answer('‚ÑπÔ∏è –õ–æ–≥-—Ñ–∞–π–ª –ø—É—Å—Ç.')
                return
            with open(LOG_FILE, 'r', encoding='utf-8') as f:
                content = f.read()
            await message.answer(f'üìù –õ–æ–≥:\n{content[-2000:]}')

        @dp.message(Command('stop'))
        async def stop(message: Message):
            await message.answer('‚ö†Ô∏è –û—Å—Ç–∞–Ω–æ–≤–∫–∞ –±–æ—Ç–∞ (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞)')
            await self.bot.session.close()
            exit(0)

        # === –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—ã–±–æ—Ä–∞ —Ñ–æ—Ä–º–∞—Ç–∞ ===
        @dp.callback_query(F.data.startswith('fmt:'))
        async def pick_format(cb: CallbackQuery):
            fmt = cb.data.split(':', 1)[1]
            sess = self._ensure_session(cb.from_user.id)
            sess.desired_format = fmt
            sess.files.clear()
            await cb.message.answer(f'‚úÖ –§–æ—Ä–º–∞—Ç –≤—ã–±—Ä–∞–Ω: {fmt.upper()}. –ó–∞–≥—Ä—É–∑–∏ –¥–≤–∞ Excel-—Ñ–∞–π–ª–∞ (RU –∏ UA).')
            await cb.answer()

        # === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–∞–π–ª–æ–≤ ===
        @dp.message(F.document)
        async def receive_file(message: Message):
            sess = self._ensure_session(message.from_user.id)
            if not sess.desired_format:
                await message.answer('‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ –≤—ã–±–µ—Ä–∏ —Ñ–æ—Ä–º–∞—Ç (XLSX –∏–ª–∏ YML).')
                return
            try:
                file = await self.bot.get_file(message.document.file_id)
                buf = await self.bot.download_file(file.file_path)
                df = pd.read_excel(io.BytesIO(buf.read()))
                df = normalize_df(df)
                sess.files.append(df)
                await message.answer(f'üìé –§–∞–π–ª –ø–æ–ª—É—á–µ–Ω. –í—Å–µ–≥–æ —Ñ–∞–π–ª–æ–≤: {len(sess.files)}')
            except Exception as e:
                await message.answer(f'‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è Excel: {e}')
                log_error(f'–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è Excel –¥–ª—è {message.from_user.id}: {e}')
                return
            if len(sess.files) < 2:
                await message.answer('‚è≥ –ñ–¥—É –≤—Ç–æ—Ä–æ–π —Ñ–∞–π–ª...')
                return
            try:
                df_ru, df_ua = sess.files[:2]
                merged = merge_ru_ua(df_ru, df_ua)
                if sess.desired_format == 'xlsx':
                    out_df = to_prom_excel(merged)
                    out_path = f'prom_{message.from_user.id}.xlsx'
                    out_df.to_excel(out_path, index=False)
                    await message.answer_document(FSInputFile(out_path), caption='üìÑ XLSX –≥–æ—Ç–æ–≤–æ')
                else:
                    xml_text = to_prom_yml(merged)
                    out_path = f'prom_{message.from_user.id}.yml'
                    with open(out_path, 'w', encoding='utf-8') as f:
                        f.write(xml_text)
                    await message.answer_document(FSInputFile(out_path), caption='üßæ YML –≥–æ—Ç–æ–≤–æ')
                sess.files.clear()
                os.remove(out_path)
            except Exception as e:
                await message.answer(f'‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞: {e}')
                log_error(f'–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Ñ–∞–π–ª–∞ –¥–ª—è {message.from_user.id}: {e}')

    def run(self):
        asyncio.run(self.dp.start_polling(self.bot))
if __name__ == '__main__':
    bot = PromBot(TOKEN)
    bot.run()
